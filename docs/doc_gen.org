#+title: Canvas Api

#+BEGIN_SRC python :results output raw :exports none
from py5canvas import canvas
from importlib import reload
import ast
reload(canvas)
from IPython.display import publish_display_data, clear_output

def disp(s):
    #print(s)
    publish_display_data({'text/org':'%s\n\n'%s})

def parse_class_with_docs_and_args(file_path, class_name):
    with open(file_path, "r") as f:
        tree = ast.parse(f.read())

    class_info = {"methods": []}

    # Find the class in the file
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef) and node.name == class_name:
            # Get class docstring
            class_info["docstring"] = ast.get_docstring(node) or "No class docstring available"

            # Process methods
            for n in node.body:
                if isinstance(n, ast.FunctionDef):
                    # Get method name
                    method_name = n.name

                    # Get method arguments (skip 'self')
                    args = [arg.arg for arg in n.args.args if arg.arg != 'self']

                    is_property = any(
                        isinstance(decorator, ast.Name) and decorator.id == 'property'
                        for decorator in n.decorator_list
                    )

                    # Get docstring (if exists)
                    docstring = ast.get_docstring(n)
                    if docstring:
                        class_info["methods"].append((method_name, is_property, docstring))

    return class_info

classname = 'Canvas'
info = parse_class_with_docs_and_args(canvas.__file__, classname)
print('* %s'%classname)
print('%s\n'%info['docstring'])

for name, is_property, doc in info['methods']:
    if '__' in name or name[0] == '_':
        continue
    if is_property:
        print('** ~%s~ (property)'%name)
    else:o
        print('** ~%s(...)~'%name)
    print('%s\n'%doc)
#+END_SRC

#+RESULTS:
* Canvas
Creates a a pycairo surface that behaves similarly to p5js

Constructor arguments:
-~width~: (~int~), width of the canvas in pixels
-~height~: (~int~), height of the canvas in pixels
-~clear_callback~ (optional): function, a callback to be called when the canvas is cleared (for internal use mostly)

** ~set_color_scale(...)~
Set color scale, e.g. if we want to specify colors in the ~0~-~255~ range, scale would be ~255~,
or if the colors are in the ~0~-~1~ range, scale will be ~1~

** ~rect_mode(...)~
Set the mode for drawing rectangles.
param mode: string, can be one of 'corner', 'center', 'radius'

** ~center~ (property)
Center of the canvas

** ~width~ (property)
The width of canvas

** ~height~ (property)
The height of canvas

** ~no_fill(...)~
Do not fill subequent shapes

** ~no_stroke(...)~
Do not stroke subequent shapes

** ~color_mode(...)~
Set the color mode for the canvas

param mode: string, can be one of 'rgb', 'hsv'
param scale: float, the scale for the color values (e.g. 255 for 0-255 range, 1 for 0-1 range)

** ~fill(...)~
Set the color of the current fill
Accepts different combination of arguments:

- A single argument specifies a grayscale value.
- Two arguments specify grayscale with opacity.
- Three arguments specify a color depending on the color mode (rgb or hsv)
- Four arguments specify a color with opacity

** ~stroke(...)~
Set the color of the current stroke
Accepts different combination of arguments:

- A single argument specifies a grayscale value.
- Two arguments specify grayscale with opacity.
- Three arguments specify a color depending on the color mode (rgb or hsv)
- Four arguments specify a color with opacity

** ~stroke_weight(...)~
Set the line width

** ~line_join(...)~
Specify the 'join' for polylines.

Arguments:
~join~ (string): can be one of "miter", "bevel" or "round"

** ~blend_mode(...)~
Specify the blending mode

Arguments:
- ~mode~ (string) can be one of: "clear", "source", "over", "in", "out", "atop",
  "dest", "dest_over", "dest_in", "dest_out", "dest_atop", "xor", "add", "saturate", "multiply", "screen", "overlay", "darken", "lighten", "color_dodge", "color_burn", "hard_light", "soft_light", "difference", "exclusion", "hsl_hue", "hsl_saturation", "hsl_color", "hsl_luminosity"
  See [[https://www.cairographics.org/operators/]] for a discussion on the different operators.

** ~line_cap(...)~
Specify the 'cap' for lines.
Arguments:
- ~cap~ (string): can be one of "butt", "round" or "square"

** ~text_size(...)~
Specify the text size
Arguments:
- ~size~ (int): the text size

** ~text_font(...)~
Specify the font to use for text rendering
Arguments:
- ~font~ (string): the name of a system font

** ~push(...)~
Save the current drawing state and transformations

** ~pop(...)~
Restore the previously pushed drawing state and transformations

** ~translate(...)~
Translate by specifying ~x~ and ~y~ offset.

Arguments:
- The offset can be specified as an array/list (e.g ~c.translate([x,y])~
  or as single arguments (e.g. ~c.translate(x, y)~)

** ~scale(...)~
Apply a scaling transformation.

Arguments:
- Providing a single number will apply a uniform transformation.
- Providing a pair of number will scale in the x and y directions.
- The scale can be specified as an array/list (e.g ~c.scale([x,y])~
or as single arguments (e.g. ~c.scale(x, y)~)'''

** ~rotate(...)~
Rotate by ~theta~ radians

** ~apply_matrix(...)~
Apply an affine (3x3) transformation matrix

** ~rotate_deg(...)~
Rotate using degrees

** ~rectangle(...)~
Draw a rectangle given top-left corner, width and heght.

Arguments:
Input arguments can be in the following formats:
 - ~[topleft_x, topleft_y], [width, height]~,
 - ~[topleft_x, topleft_y], width, height~,
 - ~topleft_x, topleft_y, width, height~
 - '[[topleft_x, topleft_y], [bottomright_x, bottomright_y]]'

** ~rect(...)~
Draw a rectangle given top-left corner, width and heght.

Arguments:
Input arguments can be in the following formats:
 - ~[topleft_x, topleft_y], [width, height]~,
 - ~[topleft_x, topleft_y], width, height~,
 - ~topleft_x, topleft_y, width, height~

** ~quad(...)~
Draws a quadrangle given four points

Arguments:
Input arguments can be in the following formats:
 - ~a, b, c, d~ (Four points specified as lists/tuples/numpy arrays
 - ~x1, y1, x2, y2, x3, y3, x4, y4~

** ~triangle(...)~
Draws a triangle given three points

Arguments:
Input arguments can be in the following formats:
 - ~a, b, c~ (Four points specified as lists/tuples/numpy arrays
 - ~x1, y1, x2, y2, x3, y3~

** ~circle(...)~
Draw a circle given center and radius

Arguments:
Input arguments can be in the following formats:
- ~[center_x, center_y], radius~,
- ~center_x, center_y, raidus~

** ~ellipse(...)~
Draw an ellipse with center, width and height.

Arguments:
Input arguments can be in the following formats:
- ~[center_x, center_y], [width, height]~,
- ~[center_x, center_y], width, height~,
- ~center_x, center_y, width, height~

** ~arc(...)~
Draw an arc given the center of the ellipse ~x, y~
the size of the ellipse ~w, h~ and the initial and final angles
in radians  ~start, stop~.

Arguments:
  Input arguments can be in the following formats:
  -~x, y, w, h, start, stop~
  -~[x, y]', '[w, h]', '[start, stop]'
  -~[x, y]', w, h, start, stop~

** ~begin_shape(...)~
Begin drawing a compound shape

** ~end_shape(...)~
End drawing a compound shape

** ~begin_contour(...)~
Begin drawing a contour

** ~end_contour(...)~
End drawing a contour

** ~vertex(...)~
Add a vertex to current contour
Arguments:
Input arguments can be in the following formats:
 ~[x, y]'
 ~x, y~

** ~curve_vertex(...)~
Add a curved vertex to current contour
Arguments:
Input arguments can be in the following formats:
 ~[x, y]'
 ~x, y~

** ~load_image(...)~
Load an image from disk. Actually returns a PIL image

** ~image(...)~
Draw an image at position with (optional) size and (optional) opacity

Arguments:
img: The input image. Can be either a PIL image, a numpy array or a pyCairo surface (e.g. another canvas).
*arguments: position and size can be specified with the following formats:
    ~x, y~:  position only
    ~x, y, w, h~: position and size
    ~[x, y]~: position only (also a numpy array or tuple are valid)
    ~[x, y], [w, h]~: position and size
if the position is not specified, the original image dimensions will be used

~opacity~: a value between 0 and 1 specifying image opacity.

** ~shape(...)~
Draw a shape represented as a list of polylines, see the ~polyline~
method for the format of each polyline

** ~text(...)~
Draw text at a given position

Arguments:
    if center=True the text will be horizontally centered

** ~polygon(...)~
Draw a *closed* polygon
The polyline is specified as either:
- a list of ~[x,y]~ pairs (e.g. ~[[0, 100], [200, 100], [200, 200]]~)
- a numpy array with shape ~(n, 2)~, representing ~n~ points (a point for each row and a coordinate for each column)

** ~polyline(...)~
Draw a polyline.
The polyline is specified as either:
- a list of ~[x,y]~ pairs (e.g. ~[[0, 100], [200, 100], [200, 200]]~)
- a numpy array with shape ~(n, 2)~, representing ~n~ points (a point for each row and a coordinate for each column)

To close the polyline set the named closed argument to ~True~, e.g. ~c.polyline(points, closed=True)~.

** ~background(...)~
Clear the canvas with a given color

** ~get_image(...)~
Get canvas image as a numpy array

** ~get_image_grayscale(...)~
Returns the canvas image as a grayscale numpy array (in 0-1 range)

** ~save_image(...)~
Save the canvas to an image

** ~save_svg(...)~
Save the canvas to an svg file

** ~save_pdf(...)~
Save the canvas to an svg file

** ~save(...)~
Save the canvas to an image

** ~show(...)~
Display the canvas in a notebook

** ~show_plt(...)~
Show the canvas in a notebook with matplotlib

Arguments:
size (tuple, optional): The size of the displayed image, by default this is the size of the canvas
title (string, optional): A title for the figure
axis (bool, optional): If ~True~ shows the coordinate axes
